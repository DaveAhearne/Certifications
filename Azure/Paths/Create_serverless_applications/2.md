# Create serverless logic with Azure Functions

## Introduction

When designing traditional architecture strategies, you need to consider things like **server infrastructure and maintenance** up front. Serverless computing will **manage and provision infrastructure for you** so you can focus on building the application logic.

Azure functions are a key component of that by letting you run bits of code or *functions* written in a programming language you like in the cloud.

## Decide if serverless computing is right for your business needs

Serverless compute is **Function As A Service** FAAS (In comparison to Platform As A Service PAAS, and Infrastucture As A Service IAAS). You don't have to manage infrastructure and **your application is scaled automatically depending on load**

The two most common approaches are:
* Azure Logic Apps
* Azure Functions

### Azure Functions
Azure Functions are a **serverless application platform**, you write some business logic as code and can run it without provisioning infrastructure, they scale automatically and **you're only charged for the time the functions are running**. A number of different languages, tools and frameworks are supported.

#### Benefits
* Don't over-allocate resources - When load is light with traditional provisioning strategies you are paying for resources you're not 100% using, this isn't the case with Functions because your allocation will scale to load and you're only charged for what you use
* The logic is stateless - Anything without state is a great candidate for the transient nature of Functions, state can be stored in associated storage devices if needed
* Event driven - Functions only run **in response to** an event (or trigger) such as a HTTP call or a message queue event, this approach simplifies code because you wire up the triggers and you can focus on application logic
* Intrgrate well to traditional problem domains - Lots of problems can easily be mapped onto a serverless architecture to take advantage of the managed infrastructure

#### Drawbacks
* Time limits - **By default, Functions have a timelimit of 5 minutes, extendable to 10 minutes**, However if your call was initiated by HTTP trigger then you're restricted to that calls timeout of **2.5 minutes**. If you do need longer than this consider *migrating to a VM* or investigating **Durable Functions**
* Cost with high frequency - If your function is going to be executed constantly by multiple clients, it might be worth *investigating the cost and comparing it to a VM*. Also be aware that new functions app instances only get created every **10 seconds, for a maximum of 200 instances**, but each instance can handle multiple concurrent executions its not a 1-1 mapping, **different types of triggers have different scaling requirements**

## Create a Function App in the Azure portal

### Whats a Function App?
All Functions are hosted in an **execution context called a Function App**. Function apps are defined to *logically group and structure functions in a compute resource*.

Function apps have two service plans to choose from:
* Consumption Service Plan - This is the default, it will automatically scale and bill you when the functions are running, it had configurable timeouts of a default of 5 minutes up to 10 minutes
* Azure App Service Plan - This plan avoids timeouts **by having your function run continuously in a VM you define**, when using this you're responsible for managing the resources so its *technically* not serverless. **This is a better choice if your functions are used continuously or if they require more processing power or compute time**

When you are creating your Function App, **its name must be globally unique**, it will serve as the base URL of your service, **valid characters are: a-z 0-9 -**

Also note that when you create a function app, **it must be linked to a storage account**. The function app uses this storage account for internal operations like logging function executions and managing execution triggers. On a consumption plan *this is where the function code and config file are stored*

**Consumption Plan** is the serverless hosting option (You pay for what you eat)

If you click into the **Function App* itself, you will see it has a URL property in the overview, clicking this will give you a default web-page to indicate that the function app is running

## Run your code on-demand with Azure Functions

### Triggers
Functions are event driven, the type of event that starts the function is called a *trigger*, you must configure **one** trigger, the following triggers are available:
* Blob Storage - Starts when a blob is created or updated
* Cosmos DB storage - Starts when inserts or updates are detected
* Event Grid - Starts a function when an event is recieved from Event Grid
* HTTP - Starts up a function with a HTTP request
* Microsoft Graph Events - Starts a fuction in response to a webhook from Microsoft Graph, each instance of the trigger can react to one Microsoft Graph type
* Queue Storage - Starts a new function when an item is recieved on the queue, the message is provided as input to the function
* Service Bus - Starts a function in response to messages from a serveice bus Queue
* Timer - Starts a function on a shedule

*(Azure storage queues are for large amounts of data; 200TB vs 80GB, it also has a message TTL max of 7 days)*

### Bindings
A binding is a declarative way to connect data and services to functions. Bindings know how to talk to the services so you don't have to write code to do it. Every binding has a direction of read/write. *Every function can have 0 or more bindings to manage inputs and outputs*

A trigger is just a special type of input binding that also has the *capability to initialize execution*

Lets say we wanted to add a new row to azure table storage when we get a new message in the queue, we can do this by:
* Adding an Azure Queue Storage *trigger*
* Add an Azure Table Storage *output binding*

function.json:
``` 
{
  "bindings": [
    {
      "name": "order",
      "type": "queueTrigger",
      "direction": "in", // Note the direction
      "queueName": "myqueue-items", // The queue name we bind to
      "connection": "MY_STORAGE_ACCT_APP_SETTING"
    },
    {
      "name": "$return",
      "type": "table",
      "direction": "out",
      "tableName": "outTable", // the table we output to
      "connection": "MY_TABLE_STORAGE_ACCT_APP_SETTING"
    }
  ]
}
```
If we wanted to, we can change this output binding to be whatever we want:
* A SendGrid binding
* An event onto Service Bus
* Or add lots of output bindings to trigger different services at once

To see the contents of the *"function.json"* file, Go to Integrate > Advanced in the Azure Portal

**NOTE:** This file won't actually be available until you create the first trigger, Go to Functions in your Function App and add a new one to be able to navigate to the file
https://docs.microsoft.com/en-us/azure/azure-functions/functions-create-first-azure-function